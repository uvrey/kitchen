LANGUAGE SPECIFICATION DOCUMENT

# Specification document for DSL design tool. Fill in the blanks.
# White space is ignored so feel free to use it as you please.
# Blank lines and lines beginning with a # are also ignored.

---

Tokens:

# (C, I, R, or T) <Token name> <Token regex or reserved word>
# 
# Use C header if you wish matches for this token to be checked against reserved words.
# Use I header if you wish this token to be ignored in parsing stage.
# Use R header if you wish this token to be a reserved word.
# Use T header if you wish no special treatment for this token.
# Remember to escape special characters: 
#     . ^ $ * + ? { } [ ] \ | ( ) 

R balance balance
R pay pay
R receive receive
R remove remove
R query query
R print print
I comment (@.*)
I whitespace \s+
T amount R(?=(\+|-|\d|\.))([+-]?)(0|([1-9](\d)*))?(\.\d\d)?
T date ((19|20)((\d\d/((((0?)[13578]|1[02])/(((0?)[1-9])|([12][0-9])|(3[01])))|(((0?)[469]|11)/(((0?)[1-9])|([12]\d)|(30)))|(((0?)2)/(((0?)[1-9])|(([12][0-8])|19)))))|(0[48]|[13579][26]|[2468][048]))|(0?)2/29)|(2000/(0?)2/29)
T time ((((0?)|1)\d)|(2[0-4]))[:][0-5]\d
C id (\w+)
T name /[a-zA-Z\-\s]*/

---

Productions:

# P <Non-terminal> -> <Production> [| <Alternate production>]
# F [<Flag>]
# I [<List of indexes>]
# 
# Empty productions may not be used as alternate productions.
# Flags are used when building the abstract syntax tree to give context to the semantic analyser. 
# Default flags are:
#     STATEMENT DECLARATION OPERATOR IDENTIFIER EMPTY
# Symbols at the listed indexes are saved in the abstract syntax tree in the order they appear. 
# 
# For example:
#    (I)    0              1       2    3      
#     P EXPRESSION -> EXPRESSION plus TERM
#     F OPERATOR
#     I 2 1 3
#     ...results in an AST entry of (OPERATOR, plus, p [1], p [3]).

P PROGRAM -> SET BLOCK
F STATEMENT
I 1 2

P SET -> balance MONEY
F OPERATOR
I 1 2

P MONEY -> amount
F AMOUNT
I 1

P BLOCK -> STATEMENT BLOCK
F STATEMENT
I 1 2

P BLOCK ->
F EMPTY
I

P STATEMENT -> query
F OPERATOR
I 1

P STATEMENT -> print
F OPERATOR
I 1

P STATEMENT -> ACTION
F
I 1

P ACTION -> remove REF
F OPERATOR
I 1 2

P REF -> id
F ID
I 1

P ACTION -> TRANSACTION
F
I 1

P TRANSACTION -> pay REF WHO WHEN EXACT MONEY | receive REF WHO WHEN EXACT MONEY
F OPERATOR
I 1 2 3 4 5 6

P WHO -> name
F NAME
I 1

P WHEN -> date
F DATE
I 1

P EXACT -> time
F TIME
I 1

P TRANSACTION -> SET
F
I 1

---

Booleans:

# T <True symbol>
# F <False symbol>
#
# This allows you to define your own boolean literals for your language.

T T
F F

---

Datatypes:

# N <Name>
# L <Literal name>
# T <Type string>
#
# Type string has to be one of:
#     BOOLEAN STRING NUMERIC
# Literal name is the flag used in the AST to reference a literal of this type.

N amount
L AMOUNT
T NUMERIC

N name
L NAME
T STRING

N date
L DATE
T STRING

N time
L TIME
T STRING

N id
L ID
T STRING

---

Operators:

# S <Symbol>
# A <Number of arguments>
# (T <List of types>)*
# F <Format string>
#
# The list of types must choose a type for each argument and, optionally, the return type last. 
# Please enter a format string corresponding to your desired Python output code.
# Remember, if these operators are used recursively, to surround your format string with parentheses.
# 
# For example:
#     S @
#     A 2
#     T int string string
#     F {1} + \" is \" + {0}
#     ...will give @ 4 "answer" = "answer is 4".

S balance
A 1
T amount
F balance = float ("{0}" [1:]); transactions = [[], []]

S query
A 0
T
F print ("Balance: R" + str (balance) + "\n")

S print
A 0
T
F for i in range (len (transactions [0])): print (transactions [0] [i] + " " + " ".join (transactions [1] [i])); print ("\n")

S pay
A 5
T id name date time amount
F if (float ("{4}" [1:]) > 0): balance = round (balance - float ("{4}" [1:]), 2); transactions [0].append ("{0}"); transactions [1].append (("{1}" [1:-1], "{2}", "{3}", "R -" + "{4}" [1:]))

S receive
A 5
T id name date time amount
F if (float ("{4}" [1:]) > 0): balance = round (balance + float ("{4}" [1:]), 2); transactions [0].append ("{0}"); transactions [1].append (("{1}" [1:-1], "{2}", "{3}", "R +" + "{4}" [1:]))

S remove
A 1
T id
F if ("{0}" in transactions [0]): index = transactions [0].index ("{0}"); value = float (transactions [1] [index] [3] [2:]); balance = round (balance - value, 2); transactions [0].pop (index); transactions [1].pop (index)

---
